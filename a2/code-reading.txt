# CSC 369 Fall 2010 - Assignment 2
#
# Zeeshan Qureshi <g0zee@cdf.toronto.edu>
# Aditya Mishra <c9mishra@cdf.toronto.edu>
# $Id$

Answer 1
--------
When a thread exits, its address space is destroyed and is marked a zombie(and later exorcized).

When thread_sleep() is called, the thread is marked as sleeping(S_SLEEP) on "sleep address" addr. When thread_wakeup is called with the same address, then the thread wakes up.


Answer 2
--------
The mi_switch() function handles a context switch


Answer 3
--------
There are 4 thread states:
  * S_RUN
  * S_READY
  * S_SLEEP
  * S_ZOMB


Answer 4
--------
Three events that can directly trigger a context switch are:
  * Trap/Exception (Software Interrupt)
  * Hardware Interrupt
  * When the thread exits

Answer 5
--------
Turning interrupts off means that the CPU will not interrupt the currently executing code on received hardware/software interrupts. This guarantees that the code will be atomic and and another thread will only be able to run when interrupts are enabled again.

This is accomplished by enabling/disabling the master interrupt flag in bit 0 of the status register.

Interrupts should be off inside the thread subsystem because it handles the creation/deletion/switching of threads for which it needs to manipulate the data structures atomically and thus should not be interrupted.

Answer 6
---------
When a thread wakep up another thread(s), the woken up thread(s) is/are made runnable(i.e. added to the 'runnable' queue), the calling thread keeps on running until it is switched out by the scheduler.

A thread sleeping on the address 'addr' gets to run again when another thread called thread_wakeup/thread_wakeone on the 'addr' at which point the sleeping thread is added to the 'runnable' queue.

Answer 7
--------
Semaphores are implemented as follows:
  * Whenever a thread calls 'wait'(P) on a semaphore, it is put to sleep 
    by calling thread_sleep()
  * When a thread calls 'signal'(V) os a semaphore, the thread waiting(sleeping) on
    that semaphore is woken up via thread_wakeup(()
